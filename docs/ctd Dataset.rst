**CTD Dataset**
#################
Base class for working with hexadecimal (.hex) files generated by SeaBird CTDs. Support for SBE16 and SBE19 Optical Backscatter Sensors (OBS).  


---------------

**Overview**
**********
----------

- Read in instrument data from raw hex format (.hex) into structured dictionary 
- Retrieve instrument data as numpy arrays 
- Correlate measurements with position data
- Calculate derived quantities such as salinity, depth, suspended solids concentrations
- Mask data based on measured and derived quality control parameters
- Apply timezone corrections to data
- Plot raw and derived quantities.
------------  


**Limitations**
**********

- currently only suports Seabird CTDs


------------  


**Loading Data**
**********

.hex files are produced by Seabird CTDs and contain raw data recorded by the instrument. Accompanying .xmlcon files contain instrument configuration information. 

Initalize a DataSet object to read a .hex and .xmlcon file pair. 

.. code-block:: python

    """Load an example ctd file .
    """
    
    # read in CTD data
    fpath_hex = r'.\example_data\fixed_adcp\fixed_ctd.hex'
    fpath_xml = r'.\example_data\fixed_adcp\fixed_ctd.xmlcon'
    ctd = pp.ctd.DataSet(filepath_hex = fpath_hex,filepath_xml = fpath_xml)
    
    
    
     

------------      
    

**Querying Data**
**********

 
There are several ways to access ensemble data 

.. :py:attr:'pyplume.ctd.seabird_hex_decoder.DataSet.data'

 
.. code-block:: python

    """Query timeseries data
    """
    
    data = ctd.data #as structured dictionary 
    
    df = ctd.to_pandas_df() # as pandas dataframe
    
    t,x = ctd.get_timeseries_data(field_name = 'Turbidity (NTU)') # time and field as numpy arrays
    
    

------------    
  

    
**Applying Timezone Correction**
**********


Timezone corrections are applied when the data are queried using :get_timeseries_data: method. Corrections are also applied on plots.  

.. code-block:: python

    """set timezone correction 
    """
    
    ctd.timezone_correction = -2 # subtract two hours from raw measurement datetimes 
------------  

**Incorporating Position Data**
**********


Position data loaded into a Pose object can be used by DasaSet objects to transform measurements into real-world coodinate systems. 

The pose attribute of a DataSet object can be set using the :geometry.set_pose method: (LINK TO POSE PAGE)

If the heading, pitch, and roll of the pose position data are suspect or missing , setting :update_depth = True: will update these fields with calculated ctd depth measurements. If depth is not already calculated, then it will be done automatically here (as lat/lon are required from pose object)

.. code-block:: python

    """create a pose object and set ctd pose attribute
    """

    # create a pose object for the ROV (timeseries of position + orientation)
    df = pd.read_csv(r'.\example_data\mobile_adcp\position.csv', parse_dates = True, index_col = [0])
    pose = pp.pose.Pose(df = df, name = 'ROV', proj = 'EPSG:32611', z_convention = 'normal')
    ctd.geometry.set_pose(pose,update_orientation = False)
    
------------    
    

**Processing**
**********

- :Density: Calculate the density of seawater using UNESCO 1983 polynomial equations of state.
- :SSC: Calculate Suspended Solids Concentration (SSC) from turbidity data. SSC = A*NTU.
- :Depth: Calculate depth from pressure following SBE APPLICATION NOTE NO. 69.
    Sea-Bird uses the formula in UNESCO Technical Papers in Marine Science
    No. 44. This is an empirical formula that takes compressibility (that is,
    density) into account. An ocean water column at 0 Â°C (t = 0) and 35 PSU
    (s = 35) is assumed. 

.. code-block:: python

    """calculate derived parameters
    """
    help(ctd.processing.calculate_density)
    help(ctd.processing.ssc)
    help(ctd.processing.calculate_depth)
    
    
    ctd.processing.calculate_density() # calculate water density 
    ctd.processing.calculate_SSC(A= 1.5) # SSC = A*NTU
    
    
    
    # create a pose object for the station (timeseries of position + orientation)
    df = pd.DataFrame({'Easting': 479753.7,
                       'Northing':1142907.6,
                       'Depth': 4330,
                       'Pitch': 0,
                       'Roll':0,
                       'Heading':0},
                        index = pd.to_datetime(adcp.get_ensemble_datetimes()))


    pose = pp.pose.Pose(df = df, name = 'Fixed Station', proj = 'EPSG:32611', z_convention = 'normal')

    # configure the ctd pose
    ctd.geometry.set_pose(pose, update_depth = True) #update pose depth based on CTD calculated depth 

    # pose object with easting/northing required for depth calculation 
    ctd.processing.calculate_depth()
    

   
RSSI parameters for each beam can also be specified in the code and supplied as an optional argument
    
.. code-block:: python

    """calculate absolute backscatter with default parameters 
    """

    k_c = {1:0.4,
           2: 0.38,
           3: 0.41,
           4: 0.39}
    adcp.processing.calculate_absolute_backscatter(k_c = k_c)
    adcp.plot.four_beam_flood_plot(field_name = 'ABSOLUTE BACKSCATTER')
        
    

------------  

       
**Plotting**
**********
----------      


.. code-block:: python

    """Four-beam flooded color plots for beam ensemble fields
    """
    fig,ax = ctd.plot.timeseries(field_name = 'Turbidity (NTU)') 

    fig,ax = ctd.plot.timeseries(field_name = 'Temperature (C)')
    
    
    
    # if pose object configured, plot trajectory
    fig,ax = ctd.geometry.pose.plot.trajectory() 

.. image:: ./_static/mobile_ctd_turbidity.png


